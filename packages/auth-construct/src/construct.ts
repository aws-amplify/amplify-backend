import { Construct } from 'constructs';
import { aws_cognito as cognito, Stack } from 'aws-cdk-lib';
import {
  AuthResources,
  BackendOutputStorageStrategy,
  BackendOutputWriter,
  ResourceProvider,
} from '@aws-amplify/plugin-types';
import {
  UserPool,
  UserPoolClient,
  UserPoolProps,
  VerificationEmailStyle,
} from 'aws-cdk-lib/aws-cognito';
import { FederatedPrincipal, Role } from 'aws-cdk-lib/aws-iam';
import { AuthOutput } from '@aws-amplify/backend-output-schemas/auth';
import { authOutputKey } from '@aws-amplify/backend-output-schemas';
import { AmplifyAuthProps } from './types.js';
import { DEFAULTS } from './defaults.js';
import {
  AuthAttributeFactory,
  AuthCustomAttributeBase,
  AuthCustomAttributeFactory,
  AuthStandardAttribute,
} from './utilities/attributes.js';

type DefaultRoles = { auth: Role; unAuth: Role };

/**
 * Amplify Auth CDK Construct
 */
export class AmplifyAuth
  extends Construct
  implements BackendOutputWriter, ResourceProvider<AuthResources>
{
  /**
   * The resources generated by the construct.
   */
  public readonly resources: AuthResources;
  /**
   * Create a new Auth construct with AuthProps.
   * If no props are provided, email login and defaults will be used.
   */
  constructor(
    scope: Construct,
    id: string,
    props: AmplifyAuthProps = DEFAULTS.IF_NO_PROPS_PROVIDED
  ) {
    super(scope, id);

    // UserPool
    const userPoolProps: UserPoolProps = this.getUserPoolProps(props);
    const userPool = new cognito.UserPool(this, 'UserPool', userPoolProps);

    // UserPool Client
    const userPoolClientWeb = new cognito.UserPoolClient(
      this,
      'UserPoolWebClient',
      {
        userPool: userPool,
        authFlows: DEFAULTS.AUTH_FLOWS,
        preventUserExistenceErrors: DEFAULTS.PREVENT_USER_EXISTENCE_ERRORS,
      }
    );

    // Auth / UnAuth Roles
    const { auth, unAuth } = this.setupAuthAndUnAuthRoles();

    // Identity Pool
    const { identityPool, identityPoolRoleAttachment } = this.setupIdentityPool(
      { auth, unAuth },
      userPool,
      userPoolClientWeb
    );

    // expose resources
    this.resources = {
      userPool,
      userPoolClientWeb,
      authenticatedUserIamRole: auth,
      unauthenticatedUserIamRole: unAuth,
      cfnResources: {
        identityPool,
        identityPoolRoleAttachment,
      },
    };
  }

  /**
   * Create Auth/UnAuth Roles
   * @returns DefaultRoles
   */
  private setupAuthAndUnAuthRoles(): DefaultRoles {
    const result: DefaultRoles = {
      auth: new Role(this, 'authenticatedUserRole', {
        assumedBy: new FederatedPrincipal('cognito-identity.amazonaws.com'),
      }),
      unAuth: new Role(this, 'unauthenticatedUserRole', {
        assumedBy: new FederatedPrincipal('cognito-identity.amazonaws.com'),
      }),
    };
    return result;
  }

  /**
   * Setup Identity Pool with default roles/role mappings, and register providers
   * @param roles - DefaultRoles
   * @param userPool - UserPool
   * @param userPoolClient - UserPoolClient
   */
  private setupIdentityPool(
    roles: DefaultRoles,
    userPool: UserPool,
    userPoolClient: UserPoolClient
  ) {
    // setup identity pool
    const region = Stack.of(this).region;
    const identityPool = new cognito.CfnIdentityPool(this, 'IdentityPool', {
      allowUnauthenticatedIdentities: DEFAULTS.ALLOW_UNAUTHENTICATED_IDENTITIES,
    });
    const identityPoolRoleAttachment =
      new cognito.CfnIdentityPoolRoleAttachment(
        this,
        'IdentityPoolRoleAttachment',
        {
          identityPoolId: identityPool.logicalId,
          roles: {
            unauthenticated: roles.unAuth.roleArn,
            authenticated: roles.auth.roleArn,
          },
          roleMappings: {
            UserPoolWebClientRoleMapping: {
              type: 'Token',
              ambiguousRoleResolution: 'AuthenticatedRole',
              identityProvider: `cognito-idp.${region}.amazonaws.com/${userPool.userPoolId}:${userPoolClient.userPoolClientId}`,
            },
          },
        }
      );
    identityPoolRoleAttachment.addDependency(identityPool);
    identityPoolRoleAttachment.node.addDependency(userPoolClient);
    // add cognito provider
    identityPool.cognitoIdentityProviders = [
      {
        clientId: userPoolClient.userPoolClientId,
        providerName: `cognito-idp.${region}.amazonaws.com/${userPool.userPoolProviderName}`,
      },
    ];
    return {
      identityPool,
      identityPoolRoleAttachment,
    };
  }

  /**
   * Process props into UserPoolProps (set defaults if needed)
   * @param props - AmplifyAuthProps
   * @returns UserPoolProps
   */
  private getUserPoolProps(props: AmplifyAuthProps): UserPoolProps {
    const emailEnabled = props.loginWith.email ? true : false;
    const phoneEnabled = props.loginWith.phoneNumber ? true : false;
    // check for customizations
    let userVerificationSettings: cognito.UserVerificationConfig = {};
    if (emailEnabled) {
      if (typeof props.loginWith.email === 'object') {
        const emailSettings = props.loginWith.email;
        if (
          emailSettings.emailBody &&
          emailSettings.emailStyle !== VerificationEmailStyle.LINK
        ) {
          if (emailSettings.emailBody.indexOf('{####}') === -1) {
            throw Error(
              "Invalid email settings. Property 'emailBody' must contain {####} as a placeholder for the verification code."
            );
          }
        }
        if (
          emailSettings.emailBody &&
          emailSettings.emailStyle === VerificationEmailStyle.LINK
        ) {
          if (emailSettings.emailBody.indexOf('{##Verify Email##}') === -1) {
            throw Error(
              "Invalid email settings. Property 'emailBody' must contain {##Verify Email##} as a placeholder for the verification link."
            );
          }
        }
        userVerificationSettings = {
          emailBody: props.loginWith.email.emailBody,
          emailStyle: props.loginWith.email.emailStyle,
          emailSubject: props.loginWith.email.emailSubject,
        };
      }
    }
    if (phoneEnabled) {
      const phoneSettings = props.loginWith.phoneNumber;
      if (typeof phoneSettings === 'object') {
        if (
          phoneSettings.verificationMessage &&
          phoneSettings.verificationMessage.indexOf('{####}') === -1
        ) {
          // validate sms message structure
          throw Error(
            "Invalid phoneNumber settings. Property 'verificationMessage' must contain {####} as a placeholder for the verification code."
          );
        }
        userVerificationSettings = {
          ...userVerificationSettings,
          smsMessage: phoneSettings.verificationMessage,
        };
      }
    }
    // extract standard and custom attributes
    let standardAttributes: cognito.StandardAttributes = {};
    let customAttributes: {
      [key: string]: cognito.ICustomAttribute;
    } = {};
    // standard attribute names must be unique to prevent unintentional behavior
    const attributeNames: Set<string> = new Set();
    // custom attribute names must be unique (they are given a 'custom:' prefix so they don't interfere with standard attributes)
    const customAttributeNames: Set<string> = new Set();
    if (props.userAttributes) {
      for (const attr of props.userAttributes) {
        if (attr instanceof AuthStandardAttribute) {
          if (attributeNames.has(attr['name'])) {
            throw new Error(
              `Invalid userAttributes. Duplicate attribute name found: ${attr['name']}.`
            );
          }
          attributeNames.add(attr['name']);
          standardAttributes = {
            ...standardAttributes,
            ...attr['_toStandardAttributes'](),
          };
        } else if (attr instanceof AuthCustomAttributeBase) {
          if (customAttributeNames.has(attr['name'])) {
            throw new Error(
              `Invalid userAttributes. Duplicate custom attribute name found: ${attr['name']}.`
            );
          }
          customAttributeNames.add(attr['name']);
          customAttributes = {
            ...customAttributes,
            ...attr['_toCustomAttributes'](),
          };
        }
      }
    }

    const userPoolProps: UserPoolProps = {
      signInCaseSensitive: DEFAULTS.SIGN_IN_CASE_SENSITIVE,
      signInAliases: {
        phone: phoneEnabled,
        email: emailEnabled,
      },
      keepOriginal: {
        email: emailEnabled,
        phone: phoneEnabled,
      },
      userVerification: userVerificationSettings,
      passwordPolicy: DEFAULTS.PASSWORD_POLICY,
      standardAttributes: {
        email: DEFAULTS.IS_REQUIRED_ATTRIBUTE.email(emailEnabled),
        phoneNumber: DEFAULTS.IS_REQUIRED_ATTRIBUTE.phoneNumber(phoneEnabled),
        ...standardAttributes,
      },
      customAttributes: {
        ...customAttributes,
      },
      selfSignUpEnabled: DEFAULTS.ALLOW_SELF_SIGN_UP,
    };
    return userPoolProps;
  }

  /**
   * Stores auth output using the provided strategy
   */
  storeOutput(
    outputStorageStrategy: BackendOutputStorageStrategy<AuthOutput>
  ): void {
    outputStorageStrategy.addBackendOutputEntry(authOutputKey, {
      version: '1',
      payload: {
        userPoolId: this.resources.userPool?.userPoolId ?? '',
        webClientId: this.resources.userPoolClientWeb?.userPoolClientId ?? '',
        authRegion: Stack.of(this).region,
      },
    });
  }

  /**
   * Utility for adding user attributes.
   *
   * Example:
   * userAttributes: [
   *  AmplifyAuth.attribute('address').mutable().required(),
   * ]
   */
  public static attribute = AuthAttributeFactory;
  /**
   * Utility for adding custom attributes.
   *
   * Example:
   * userAttributes: [
   *  AmplifyAuth.customAttribute.number('petsCount').min(0).max(5)
   * ]
   */
  public static customAttribute = new AuthCustomAttributeFactory();
}
